using System;
using System.Collections.Generic;
using System.Linq;
using static Expr;
using static Function;

public interface IExpr
{
    IEnumerable<string> Variables { get; }
    bool IsConstant { get; }
    bool IsPolynomial { get; }
    int PolynomialDegree { get; }
    double Compute(IReadOnlyDictionary<string, double> variableValues);
    Expr Simplify();
}

public abstract class Expr : IExpr
{
    public abstract IEnumerable<string> Variables { get; }
    public abstract bool IsConstant { get; }
    public abstract bool IsPolynomial { get; }
    public abstract int PolynomialDegree { get; }
    public abstract double Compute(IReadOnlyDictionary<string, double> variableValues);
    public virtual Expr Simplify() => this; // По умолчанию упрощение не происходит

    public static implicit operator Expr(double arg) => new Constant(arg);

    // Бинарные и унарные операторы
    public static Expr operator +(Expr operand) => new UnaryPlus(operand);
    public static Expr operator -(Expr operand) => new UnaryMinus(operand);
    public static Expr operator +(Expr a, Expr b) => new BinaryAddition(a, b).Simplify();
    public static Expr operator -(Expr a, Expr b) => new BinarySubtraction(a, b).Simplify();
    public static Expr operator *(Expr a, Expr b) => new Multiplication(a, b).Simplify();
    public static Expr operator /(Expr a, Expr b) => new Division(a, b).Simplify();
}

public class Constant : Expr
{
    public double Value { get; }
    
    public Constant(double value) => Value = value;

    public override IEnumerable<string> Variables => Enumerable.Empty<string>();
    public override bool IsConstant => true;
    public override bool IsPolynomial => true;
    public override int PolynomialDegree => 0;
    public override double Compute(IReadOnlyDictionary<string, double> variableValues) => Value;
    public override Expr Simplify() => this;
    public override string ToString() => Value.ToString();
}

public class Variable : Expr
{
    public string Name { get; }

    public Variable(string name) => Name = name;

    public override IEnumerable<string> Variables
    {
        get { yield return Name; }
    }
    public override bool IsConstant => false;
    public override bool IsPolynomial => true;
    public override int PolynomialDegree => 1;
    public override double Compute(IReadOnlyDictionary<string, double> variableValues)
    {
        if (variableValues.TryGetValue(Name, out double value)) return value;
        else throw new ArgumentException($"Переменная {Name} не определена.");
    }
    public override string ToString() => Name;
}

public abstract class UnaryOperation : Expr
{
    protected Expr Operand { get; }

    protected UnaryOperation(Expr operand) => Operand = operand;

    public override IEnumerable<string> Variables => Operand.Variables;
    public override bool IsConstant => Operand.IsConstant;
    public override bool IsPolynomial => Operand.IsPolynomial;
    public override int PolynomialDegree => Operand.PolynomialDegree;
}

public class UnaryPlus : UnaryOperation
{
    public UnaryPlus(Expr operand) : base(operand) { }

    public override double Compute(IReadOnlyDictionary<string, double> variableValues) => Operand.Compute(variableValues);
    public override string ToString() => $"+({Operand})";
    public override Expr Simplify() => Operand.Simplify();
}

public class UnaryMinus : UnaryOperation
{
    public UnaryMinus(Expr operand) : base(operand) { }

    public override double Compute(IReadOnlyDictionary<string, double> variableValues) => -Operand.Compute(variableValues);
    public override string ToString() => $"-({Operand})";
    public override Expr Simplify() => new UnaryMinus(Operand.Simplify());
}

public abstract class BinaryOperation : Expr
{
    protected Expr A { get; }
    protected Expr B { get; }

    protected BinaryOperation(Expr a, Expr b)
    {
        A = a;
        B = b;
    }
